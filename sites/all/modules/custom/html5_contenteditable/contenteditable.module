<?php

/**
 * Implements hook_field_formatter_info()
 */
 function contenteditable_field_formatter_info() {
 	return array(
 		'contenteditable'=>	array(
 								'label'			=>	t('contentEditable'),
 								'field types'	=> 	array('text', 'text_long', 'text_with_summary', 'list_text',),
 								'settings'		=> 	array('fallback_format' => NULL,),
							),
	);
 }
 
 /**
  * Implements hook_field_formatter_settings_form()
  */
  
  function contenteditable_field_formatter_settings_form($field , $instance , $view_mode , $form , &$form_state ) {
  	
	//This gets the view_mode where our settings are stored
	$display = $instance['display'][$view_mode];
	
	//This gets the actual settings
	$settings 	= 	$display['settings'];
	$element	= 	array();
	
	//had an issue when usin this formatter in a View, 
	//results in a Fatal error: undefined function field_ui_formatter_options()
	if (!function_exists(field_ui_formatter_options)) {
		module_load_include('inc', 'field_ui' , 'field_ui.admin');
	}
	
	//fallback formatter
	//Get the list of formatters for this field type, and remove our own
	$formatters = field_ui_formatter_options($field['type']);
	unset($formatters['contenteditable']);
	
	$element['fallback_format'] = 	array (
			
		'#type'			=>	'select',
		'#title'		=>	t('Fallback formatter'),
		'#options'		=>	$formatters,
		'#description'	=> 	t('Select formatter to be used for users that don\'t have permisision to edit the filed.'), //help text
		'#default_value'=>	$settings['fallback_format'],
	);
	return $element;
  }
  
  /**
   * Implements hook_field_formatter_settings_summary()
   */
   
   function contenteditable_field_formatter_settings_summary($field , $instance , $view_mode) {
   		$display 		= $instance['display'][$view_mode];
		$settings		= $display['settings'];
		$formatter_type	= field_info_formatter_types($settings['fallback_format']);
		
		//get label of fallback formatter for summary info
		$summary	= 	t('Fallback format: @fallback_format format (Select format to be used when not in edit mode.)', 
						array('@fallback_format' => $formatter_type['label'],)
						);
		//we use t() for translation and placeholders to guard against attacks
		
		return $summary;
   }
   
   /**
    * Implements hook_field_formatter_view()
    */
    
    function contenteditable_field_formatter_view($entity_type , $entity , $field , $instance , $langcode , $items , $display) {
    		
    	//See if access to edit this field is restricted,
    	//if so, use the default formatter
    	
    	if (!entity_access('update', $entity_type, $entity) || !field_access('edit', $field, $entity_type, $entity)) { // can't edit
    		return contenteditable_fallback_formatter($entity_type , $entity , $field , $instance , $langcode , $items , $display);
    	}
		
		$element = array();
		
		foreach ($items as $delta => $item) { 
			$element[$delta] = array(
				'#markup' => '<div contentEditable="true" data-tooltip="click to edit" data-nid="'. $entity->nid . '" data-fieldname="' . $field['fieldname']. '">' . $item['value'] . '</div>');
		}
		
		return $element;
			
	}
	
	/**
	 * Format a field using hte fallback formatter of the contenteditable field
	 */
	 
	 function contenteditable_fallback_formatter( $entity_type , $entity , $field , $instance , $langcode , $items , $display ) {
	 	
		//Set the fallback formatter
		$display['type']	= 	$display['settings']['fallback_format'];
		$formatter_type 	=	field_info_formatter_types($display['type']);
		$display['module']	=	$formatter_type['module'];
		
		//Clone the entity to avoid messing with it.
		$cloned_entity		=	clone $entity;
		
		return field_view_field( $entity_type , $cloned_entity , $field['field_name'] , $display , $langcode);
	 }
    
